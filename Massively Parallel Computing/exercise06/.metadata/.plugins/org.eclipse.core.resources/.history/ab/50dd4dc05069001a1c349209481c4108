#include "gltools.h"
#include "Tools.h"

#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

using namespace std;

#define GUI
#define NUM_FRAMES 10000

#define THREADS_PER_BLOCK 128
#define EPS_2 0.00001f
#define GRAVITY 0.00000001f

float randF(const float min = 0.0f, const float max = 1.0f)
{
	int randI = rand();
	float randF = (float) randI / (float) RAND_MAX;
	float result = min + randF * (max - min);

	return result;
}

inline __device__ float2 operator+(const float2 op1, const float2 op2)
{
	return make_float2(op1.x + op2.x, op1.y + op2.y);
}

inline __device__ float2 operator-(const float2 op1, const float2 op2)
{
	return make_float2(op1.x - op2.x, op1.y - op2.y);
}

inline __device__ float2 operator*(const float2 op1, const float op2)
{
	return make_float2(op1.x * op2, op1.y * op2);
}

inline __device__ float2 operator/(const float2 op1, const float op2)
{
	return make_float2(op1.x / op2, op1.y / op2);
}

inline __device__ void operator+=(float2 &a, const float2 b)
{
	a.x += b.x;
	a.y += b.y;
}

__global__ void updateAccelerationsKernel(float2 *gpuAccelerations, float2 *gpuPositions,
		float *gpuMasses)
{
	int i = blockDim.x*blockIdx.x + threadIdx.x;
	float2 iPosition = gpuPositions[i];
//	float iMass = gpuMasses[i];

	extern __shared__ float2 sharedPositions[THREADS_PER_BLOCK];
	extern __shared__ float sharedMasses[THREADS_PER_BLOCK];


	for (int b = 0; b < gridDim.x; b++) {
//		printf("%d %d %d\n", gridDim.x, b, threadIdx.x);
		sharedPositions[threadIdx.x] = gpuPositions[blockDim.x*b+threadIdx.x];
		sharedMasses[threadIdx.x] = gpuMasses[blockDim.x*b+threadIdx.x];
//		printf("%d: %f %f\n", threadIdx.x, sharedPositions[threadIdx.x].x, sharedPositions[threadIdx.x].y);
		printf("%d: %f\n", threadIdx.x, sharedMasses[threadIdx.x]);
//		printf("\n");
		__syncthreads();
		for (int j = 0; j < blockDim.x; j++) {
			float2 r_ij = {sharedPositions[j].x - iPosition.x,
						sharedPositions[j].y - iPosition.y};

//			printf("%f %f\n", );

			float denomt = sqrtf(r_ij.x*r_ij.x + r_ij.y*r_ij.y + EPS_2);

//			printf("%f ", r_ij*sharedMasses[j] / (denomt*denomt*denomt));

			gpuAccelerations[i] += r_ij*sharedMasses[j] / (denomt*denomt*denomt);
		}
		__syncthreads();
	}
	gpuAccelerations[i].x *= GRAVITY;
	gpuAccelerations[i].y *= GRAVITY;
//	printf("%d: %f %f\n", i, gpuAccelerations[i].x, gpuAccelerations[i].y);
}

// TODO 4: Update velocities and positions of all bodies here.
__global__ void updateVelPos(float2 *gpuPositions, float2 *gpuVelocities,
		float2 *gpuAccelerations)
{
	int ind = blockDim.x*blockIdx.x + threadIdx.x;

	gpuVelocities[ind] += gpuAccelerations[ind];
	gpuPositions[ind] += gpuVelocities[ind];
}

//__global__ void mapKernel(float2 *gpuAccElements, float2 *gpuPositions, float *gpuMasses,
//		int numBodies)
//{
//	int j = blockDim.x*blockIdx.x + threadIdx.x;
//	int i = blockDim.y*blockIdx.y;
//	float2 r_ij;
//
//	r_ij.x = gpuPositions[j].x - gpuPositions[i].x;
//	r_ij.y = gpuPositions[j].y - gpuPositions[i].y;
//	float denomt = sqrtf(r_ij.x*r_ij.x + r_ij.y*r_ij.y + EPS_2);
//
//	// gravity could've been taken outside, but this seemed more logical place then reduce
//	// or even new kernel just to copy results from final result of reduce to Accelerations
//	// and multiply by G
//	gpuAccElements[i*numBodies + j] = (r_ij*gpuMasses[j]) * GRAVITY / (denomt*denomt*denomt);
//}
//__global__ void reduceKernel(float2 *gpuBlockReduced, float2 *gpuAccElements, int numBodies)
//{
//	int j = blockDim.x*blockIdx.x + threadIdx.x;
//	int i = blockDim.y*blockIdx.y;
//	int t = threadIdx.x;
//
//	extern __shared__ float2 partialSum[];
//	partialSum[t] = gpuBlockReduced[numBodies*i + j];
//
//	__syncthreads();
//
//	for (int stride = blockDim.x/2; stride >= 1; stride >>= 1) {
//		__syncthreads();
//		if (t < stride)
//			partialSum[threadIdx.x] += partialSum[t];
//	}
//	__syncthreads();
//
//	gpuBlockReduced[numBodies*i + blockIdx.x] = partialSum[0];
//}

int main(int argc, char **argv)
{
	if (argc != 2)
	{
		cout << "Usage: " << argv[0] << " <numBodies>" << endl;
		return 1;
	}
	unsigned int numBodies = atoi(argv[1]);
	unsigned int numBlocks = numBodies / THREADS_PER_BLOCK;
	numBodies = numBlocks * THREADS_PER_BLOCK;

	// allocate memory
	float2* hPositions = new float2[numBodies];
	float2* hVelocities = new float2[numBodies];
	float* hMasses = new float[numBodies];

	// Initialize Positions and speed
	for (unsigned int i = 0; i < numBodies; i++)
	{
		hPositions[i].x = randF(-1.0, 1.0);
		hPositions[i].y = randF(-1.0, 1.0);
		hVelocities[i].x = hPositions[i].y * 0.007f + randF(0.001f, -0.001f);
		hVelocities[i].y = -hPositions[i].x * 0.007f + randF(0.001f, -0.001f);
		hMasses[i] = randF(0.0f, 1.0f) * 10000.0f / (float) numBodies;
	}

	// TODO 1: Allocate GPU memory for
	// - Positions,
	// - Velocities,
	// - Accelerations and
	// - Masses
	// of all bodies and initialize them from the CPU arrays (where available).
	float2 *gpuPositions, *gpuVelocities, *gpuAccelerations;
	float *gpuMasses;

	cudaMalloc((void **) &gpuPositions, numBodies*sizeof(float2));
	cudaMalloc((void **) &gpuVelocities, numBodies*sizeof(float2));
	cudaMalloc((void **) &gpuAccelerations, numBodies*sizeof(float));
	cudaMalloc((void **) &gpuMasses, numBodies*sizeof(float));

	cudaMemcpy(gpuPositions, hPositions, numBodies*sizeof(float2), cudaMemcpyHostToDevice);
	cudaMemcpy(gpuVelocities, hVelocities, numBodies*sizeof(float2), cudaMemcpyHostToDevice);

	// Free host memory not needed again
	delete[] hVelocities;
	delete[] hMasses;

	// Initialize OpenGL rendering
#ifdef GUI
	initGL();
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	GLuint sp = createShaderProgram("white.vs", 0, 0, 0, "white.fs");

	GLuint vb;
	glGenBuffers(1, &vb);
	GL_CHECK_ERROR;
	glBindBuffer(GL_ARRAY_BUFFER, vb);
	GL_CHECK_ERROR;
	glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 2 * numBodies, hPositions,
			GL_STATIC_DRAW);
	GL_CHECK_ERROR;
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	GL_CHECK_ERROR;

	GLuint va;
	glGenVertexArrays(1, &va);
	GL_CHECK_ERROR;
	glBindVertexArray(va);
	GL_CHECK_ERROR;
	glBindBuffer(GL_ARRAY_BUFFER, vb);
	GL_CHECK_ERROR;
	glEnableVertexAttribArray(glGetAttribLocation(sp, "inPosition"));
	GL_CHECK_ERROR;
	glVertexAttribPointer(glGetAttribLocation(sp, "inPosition"), 2, GL_FLOAT,
			GL_FALSE, 0, 0);
	GL_CHECK_ERROR;
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	GL_CHECK_ERROR;
	glBindVertexArray(0);
	GL_CHECK_ERROR;
#endif

//	float2 *gpuAccElements;
//	float2 *gpuBlockReduced;
//	cudaMalloc((void **) &gpuAccElements, numBodies*numBodies*sizeof(float2));
//	cudaMalloc((void **) &gpuBlockReduced, numBodies*numBlocks*sizeof(float2));

//	dim3 numBlocks2d(numBodies, numBlocks, 1);
//	int numBlocksResult = numBodies;

	// Calculate
	for(unsigned int t = 0; t < NUM_FRAMES; t++)
	{
		__int64_t computeStart = continuousTimeNs();

		// TODO 3: Update accelerations of all bodies here.

		updateAccelerationsKernel<<<numBlocks, THREADS_PER_BLOCK, THREADS_PER_BLOCK*(sizeof(float2)+sizeof(float))>>>
				(gpuAccelerations, gpuPositions, gpuMasses);

		// i-th row of gpuDistance contains individual summands of (1)
//		mapKernel<<<numBlocks2d, THREADS_PER_BLOCK>>>(gpuAccElements, gpuPositions,
//				gpuMasses, numBodies);
		// calculates accelerations by reducing results (on multiple levels)
//		reduceKernel<<<numBlocks2d, THREADS_PER_BLOCK, THREADS_PER_BLOCK*sizeof(float2)>>>
//				(gpuBlockReduced, gpuAccElements, numBodies);
//		reduceKernel<<<numBlocksResult, numBlocks, numBlocks*sizeof(float2)>>>
//				(gpuAccelerations, gpuBlockReduced, numBodies);
		// TODO 4: Update velocities and positions of all bodies here.
		updateVelPos<<<numBlocks, THREADS_PER_BLOCK>>>(gpuPositions, gpuVelocities, gpuAccelerations);

		cudaThreadSynchronize();
		cout << "Frame compute time: " << (continuousTimeNs() - computeStart)
				<< "ns" << endl;

		// TODO 5: Download the updated positions into the hPositions array for rendering.

		cudaMemcpy(hPositions, gpuPositions, numBodies*sizeof(float), cudaMemcpyDeviceToHost);
#ifdef GUI
		// Upload positions to OpenGL
		glBindBuffer(GL_ARRAY_BUFFER, vb);
		GL_CHECK_ERROR;
		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 2 * numBodies, hPositions,
				GL_STATIC_DRAW);
		GL_CHECK_ERROR;
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		GL_CHECK_ERROR;

		// Draw
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		GL_CHECK_ERROR;
		glUseProgram(sp);
		GL_CHECK_ERROR;
		glBindVertexArray(va);
		GL_CHECK_ERROR;
		glDrawArrays(GL_POINTS, 0, numBodies);
		GL_CHECK_ERROR;
		glBindVertexArray(0);
		GL_CHECK_ERROR;
		glUseProgram(0);
		GL_CHECK_ERROR;
		swapBuffers();
#endif
	}

#ifdef GUI
	cout << "Done." << endl;
	sleep(2);
#endif

	// Clean up
#ifdef GUI
	glDeleteProgram(sp);
	GL_CHECK_ERROR;
	glDeleteVertexArrays(1, &va);
	GL_CHECK_ERROR;
	glDeleteBuffers(1, &vb);
	GL_CHECK_ERROR;

	glDeleteProgram(sp);
	exitGL();
#endif

	// TODO 2: Clean up your allocated memory
	cudaFree(gpuPositions);
	cudaFree(gpuVelocities);
	cudaFree(gpuAccelerations);
	cudaFree(gpuMasses);
//	cudaFree(gpuAccElements);
//	cudaFree(gpuBlockReduced);

	delete[] hPositions;
}

